// Template for generation of c based json parsers
use model;
use filehandler;
use util;



//
// Generates Files for Utilities
//
fn generate_buffer_code(folder:&str) {
  generate_sj_buffer_c(folder);
  generate_sj_buffer_h(folder);
}

//
// Buffer-Code-File
//
fn generate_sj_buffer_c(folder:&str) {
  let mut str:String = String::new();
  
  str.push_str("#include \"sj_buffer.h\"\n#include <stdlib.h>\n#include <string.h>\n\n// Defines the steps for increasing the buffer size\n#define BUFSIZE_STEP 1024\n\n/*\n * Create a new buffer instance\n */\nSjBuffer* sj_buffer_new() {\n    SjBuffer *buf = (SjBuffer*)malloc(sizeof(SjBuffer*));\n    buf->buf = (char*)malloc(sizeof(char)*BUFSIZE_STEP);\n    buf->length = 0;\n    buf->buffer_size = BUFSIZE_STEP;\n    return buf;\n}\n\n/*\n * Add a char to a buffer\n */\nvoid sj_buffer_push(SjBuffer *buf, char c) {\n    if(buf->length+2 >= buf->buffer_size) {\n        // Increase buffer size\n        char *b2 = (char*)malloc(sizeof(char)*(buf->buffer_size+BUFSIZE_STEP));\n        strncpy(b2, buf->buf, buf->buffer_size);\n        buf->buffer_size += BUFSIZE_STEP;\n        free(buf->buf);\n        buf->buf = b2;\n    } \n    // Add a char to the buffer\n    buf->length += 1;\n    buf->buf[buf->length-1] = c;\n    buf->buf[buf->length] = '\\0';\n}\n\n/*\n * Get the used size of the buffer\n */\nint sj_buffer_get_size(SjBuffer *buf) {\n    return buf->length;\n}\n\n/*\n * Gets the content of the given buffer \n */\nchar* sj_buffer_get_content(SjBuffer *buf) { \n    char *tmp_buf = (char*)malloc(sizeof(char)*(buf->length+1));\n    strncpy(tmp_buf, buf->buf, (buf->length+1));\n    return tmp_buf;\n}\n\n/*\n * Clean content of buffer\n */\nvoid sj_buffer_clean(SjBuffer *buf) {\n    buf->length = 0;\n    buf->buf[0] = '\\0';\n    buf->buf[1] = '\\0';\n}\n\n/*\n * Free Buffer from Memory\n */\nvoid sj_buffer_free(SjBuffer *buf) {\n    free(buf->buf);\n    free(buf);\n}");

  let filename = format!("{}/{}", folder, "sj_buffer.c");
  let result = format!("{}", str);
  filehandler::write_file(filename, result);
}

//
// Buffer-Header-File
//
fn generate_sj_buffer_h(folder:&str) {
  let mut str:String = String::new();
  
  str.push_str("#ifndef SJ_BUFFER_H\n#define SJ_BUFFER_H\n\ntypedef struct sj_buffer {\n    char *buf;\n    int length;\n    int buffer_size;\n} SjBuffer;\n\n/*\n * Create a new buffer instance\n */\nSjBuffer* sj_buffer_new();\n\n/*\n * Add a char to a buffer\n */\nvoid sj_buffer_push(SjBuffer *buf, char c);\n\n/*\n * Free Buffer from Memory\n */\nvoid sj_buffer_free(SjBuffer *buf);\n\n/*\n * Clean Content of Buffer\n */\nvoid sj_buffer_clean(SjBuffer *buf);\n\n/*\n * Get the used size of the buffer\n */\nint sj_buffer_get_size(SjBuffer *buf);\n\n/*\n * Gets a copy of the content of the given buffer \n */\nchar* sj_buffer_get_content(SjBuffer *buf);\n\n#endif");

  let filename = format!("{}/{}", folder, "sj_buffer.h");
  let result = format!("{}", str);
  filehandler::write_file(filename, result);
}


fn generate_header(types:&Box<Vec<Box<model::Type>>>, folder:&str) {
  let mut str:String = String::new(); 


  str.push_str("/*\n* C code generated by staticjson\n*/\n#ifndef JSONINC_PARSER_H\n#define JSONINC_PARSER_H\n");
/*
 * Generation C structs for staticjson types
 */
for typ in (*types).iter() { 
    str.push_str("\ntypedef struct ");
    str.push_str(&util::ucamel_to_lsnake(&typ.typename));
    str.push_str(" {");
 for attribut in typ.attributes.iter() {
    if attribut.is_array { 
      if attribut.attribute_type == "string" { 
          str.push_str("\n        char **");
          str.push_str(&attribut.name);
          str.push_str(";\n        int ");
          str.push_str(&attribut.name);
          str.push_str("_length;");

      } else if attribut.attribute_type == "int" { 
          str.push_str("\n        int *");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "uint" { 
          str.push_str("\n        unsigned int *");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "long" { 
          str.push_str("\n        long *");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "ulong" { 
          str.push_str("\n        unsigned long *");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "decimal" { 
          str.push_str("\n        double *");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "date" { 
          str.push_str("\n        // ERROR: at ");
          str.push_str(&attribut.name);
          str.push_str("\n        // Date is currently unsupported in C Parsers");

      } else { 
        // TODO: date, datetime and time missing !!! 
          str.push_str("\n        ");
          str.push_str(&attribut.attribute_type);
          str.push_str(" **");
          str.push_str(&attribut.name);
          str.push_str(";");

      }
    } else {
      if attribut.attribute_type == "string" { 
          str.push_str("\n        char *");
          str.push_str(&attribut.name);
          str.push_str(";\n        int ");
          str.push_str(&attribut.name);
          str.push_str("_length;");

      } else if attribut.attribute_type == "int" { 
          str.push_str("\n        int ");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "uint" { 
          str.push_str("\n        unsigned int ");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "long" { 
          str.push_str("\n        long ");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "ulong" { 
          str.push_str("\n        unsigned long ");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "decimal" { 
          str.push_str("\n        double ");
          str.push_str(&attribut.name);
          str.push_str(";");

      } else if attribut.attribute_type == "date" { 
          str.push_str("\n        // ERROR: at ");
          str.push_str(&attribut.name);
          str.push_str("\n        // Date is currently unsupported in C Parsers");

      } else { 
          str.push_str("\n        ");
          str.push_str(&attribut.attribute_type);
          str.push_str(" *");
          str.push_str(&attribut.name);
          str.push_str(";");

      } 
        str.push_str("");
 } }

    str.push_str("\n} ");
    str.push_str(&typ.typename);
    str.push_str(";\n");
}

  str.push_str("\n/*\n * Generation of parser function stubs\n */ \n");
for typ in (*types).iter() { 
    str.push_str("");
    str.push_str(&typ.typename);
    str.push_str("* sj_parse_");
    str.push_str(&util::ucamel_to_lsnake(&typ.typename) 
);
    str.push_str("(int *pos, char *txt);");
} 
  str.push_str("\n\n#endif");
  let filename = format!("{}/jsoninc_parser.h", folder);
  filehandler::write_file(filename, str);
}

fn generate_parsers(types:&Box<Vec<Box<model::Type>>>, folder:&str) {
  let mut str:String = String::new(); 


  str.push_str("/*\n* C code generated by staticjson\n*/\n#include \"jsoninc_parser.h\"\n#include \"sj_buffer.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// REGION Parser state definitions");
for typ in (*types).iter() {
    let t = util::to_upper(&typ.typename); 

    str.push_str("\n// parser states for ");
    str.push_str(&typ.typename);
    str.push_str("\ntypedef enum {\n  SJ_");
    str.push_str(&t);
    str.push_str("_INITIAL = 0; \n  SJ_");
    str.push_str(&t);
    str.push_str("_INOBJECT = 1;\n  SJ_");
    str.push_str(&t);
    str.push_str("_INFIELDNAME = 2;  ");
   let mut enum_idx = 0;
   for attribut in typ.attributes.iter() { 
      enum_idx += 1;
      let enum_idx_str = format!("{}", enum_idx);
      let fieldname = util::to_upper(&attribut.name);

      if attribut.is_array { 
        str.push_str("\n        // Array attribute parser states\n        // TODO: Implementation still missing");
   } else {
        // Scalar attribute parser states
        if attribut.attribute_type == "string" 
           || attribut.attribute_type == "date"
           || attribut.attribute_type == "datetime"
           || attribut.attribute_type == "time" { 
          str.push_str("\n  SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_BEHINDFIELDNAME = ");
          str.push_str(&enum_idx_str);
          str.push_str("0,\n  SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_INVALUE = ");
          str.push_str(&enum_idx_str);
          str.push_str("1,\n  SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_INSTRING = ");
          str.push_str(&enum_idx_str);
          str.push_str("2,");
       } else if attribut.attribute_type == "int" 
           || attribut.attribute_type == "uint"
           || attribut.attribute_type == "long"
           || attribut.attribute_type == "ulong" { 
          str.push_str("\n  SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_BEHINDFIELDNAME = ");
          str.push_str(&enum_idx_str);
          str.push_str("0,\n  SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_INVALUE = ");
          str.push_str(&enum_idx_str);
          str.push_str("1,");
       }
      }
   } 
    str.push_str("\n  SJ_");
    str.push_str(&t);
    str.push_str("_FINAL = 9\n} Sj");
    str.push_str(&typ.typename);
    str.push_str("Enum;");
} 
  str.push_str("\n// ENDREGION Parser state definitions");
for typ in (*types).iter() {
    let typ_upper = util::to_upper(&typ.typename); 
    let typ_lower = util::to_lower(&typ.typename); 

    str.push_str("\n\n// Function for Initial-State \nvoid sj_");
    str.push_str(&typ_lower);
    str.push_str("_doInitial(char c, Sj");
    str.push_str(&typ.typename);
    str.push_str("Enum *state) {\n    if(c == '{') {\n        *state = SJ_");
    str.push_str(&typ_upper);
    str.push_str("_INOJBECT;\n    }\n}\n\n// Function for InObject-State\nvoid sj_");
    str.push_str(&typ_lower);
    str.push_str("_doInObject(char c, Sj");
    str.push_str(&typ.typename);
    str.push_str("Enum *state) {\n    if(c == '\"') {\n        *state = SJ_");
    str.push_str(&typ_upper);
    str.push_str("_INFIELDNAME;\n    }\n}\n\n// Function for InFieldname-State\nvoid sj_");
    str.push_str(&typ_lower);
    str.push_str("_doInFieldname(char c, Sj");
    str.push_str(&typ.typename);
    str.push_str("Enum *state, SjBuffer *buf) {\n    if(c == '\"') {\n        char *name = sj_buffer_get_content(buf);");
for attribut in typ.attributes.iter() { 
      str.push_str("\n        if(strcmp(name, \"");
      str.push_str(&attribut.name);
      str.push_str("\") == 0) {\n            sj_buffer_clean(buf);\n            printf(\"");
      str.push_str(&attribut.name);
      str.push_str("\\n\");\n            *state = SJ_");
      str.push_str(&typ_upper);
      str.push_str("_");
      str.push_str(&util::to_upper(&attribut.name));
      str.push_str("_BEHINDFIELDNAME;\n        } else");
} 
    str.push_str(" {\n            printf(\"INVALID TOKEN: %s\\n\", sj_buffer_get_content(buf));\n            exit(-1);\n        }\n    } else {\n        sj_buffer_push(buf, c);\n    }\n}\n");
for attribut in typ.attributes.iter() {
    if attribut.attribute_type == "string" { 
        str.push_str("\n// Attribute specific functions for ");
        str.push_str(&typ.typename);
        str.push_str(".");
        str.push_str(&attribut.name);
        str.push_str("\nvoid sj_");
        str.push_str(&typ_lower);
        str.push_str("_do");
        str.push_str(&util::lsnake_to_ucamel(&attribut.name));
        str.push_str("BehindFieldname(char c, Sj");
        str.push_str(&typ.typename);
        str.push_str("StateEnum *state) {\n    //printf(\"SJ_");
        str.push_str(&typ_upper);
        str.push_str("_");
        str.push_str(&util::to_upper(&attribut.name));
        str.push_str("_INVALUE\\n\");\n    if(c == ':') {\n        *state = SJ_");
        str.push_str(&typ_upper);
        str.push_str("_");
        str.push_str(&util::to_upper(&attribut.name));
        str.push_str("_INVALUE;\n    } // else if(!is_whitespace(c)) { return error_code }\n}\n\nvoid sj_");
        str.push_str(&typ_lower);
        str.push_str("_do");
        str.push_str(&util::lsnake_to_ucamel(&attribut.name));
        str.push_str("InValue(char c, Sj");
        str.push_str(&typ.typename);
        str.push_str("StateEnum *state, SjBuffer *buf) {\n    if(c == '\"') {\n        *state = SJ_");
        str.push_str(&typ_upper);
        str.push_str("_");
        str.push_str(&util::to_upper(&attribut.name));
        str.push_str("_INSTRING;\n    } if (c == ',') {\n        *state = SJ_");
        str.push_str(&typ_upper);
        str.push_str("_INOJBECT;\n    } // else if(!is_whitespace(c)) { return error_code }\n}\n\nvoid sj_");
        str.push_str(&typ_lower);
        str.push_str("_do");
        str.push_str(&util::lsnake_to_ucamel(&attribut.name));
        str.push_str("InString(char c, Sj");
        str.push_str(&typ.typename);
        str.push_str("StateEnum *state, SjBuffer *buf, Sj");
        str.push_str(&typ.typename);
        str.push_str(" *");
        str.push_str(&typ_lower);
        str.push_str(") {\n    if (c == '\"') {\n        *state = SJ_");
        str.push_str(&typ_upper);
        str.push_str("_");
        str.push_str(&util::to_upper(&attribut.name));
        str.push_str("_INVALUE;\n        ");
        str.push_str(&typ_lower);
        str.push_str("->");
        str.push_str(&attribut.name);
        str.push_str(" = sj_buffer_get_content(buf);\n        ");
        str.push_str(&typ_lower);
        str.push_str("->");
        str.push_str(&attribut.name);
        str.push_str("_len = sj_buffer_get_size(buf);\n        printf(\"");
        str.push_str(&util::to_upper(&attribut.name));
        str.push_str(": %s\\n\", ");
        str.push_str(&typ_lower);
        str.push_str("->");
        str.push_str(&attribut.name);
        str.push_str(");\n        sj_buffer_clean(buf);\n    } else {\n        sj_buffer_push(buf, c);\n    }\n}\n// ---\n   ");
} else if attribut.attribute_type == "int"
              || attribut.attribute_type == "uint"
              || attribut.attribute_type == "long"
              || attribut.attribute_type == "ulong" { 
        str.push_str("\n// Parser for Numbers\nvoid sj_");
        str.push_str(&typ_lower);
        str.push_str("_do");
        str.push_str(&util::lsnake_to_ucamel(&attribut.name));
        str.push_str("BehindFieldname(char c, Sj");
        str.push_str(&typ.typename);
        str.push_str("StateEnum *state) {\n    if(c == ':') {\n        *state = SJ_");
        str.push_str(&typ_upper);
        str.push_str("_");
        str.push_str(&util::to_upper(&attribut.name));
        str.push_str("_INVALUE;\n    } // else if(!is_whitespace(c)) { return error_code }\n}\n\nvoid sj_");
        str.push_str(&typ_lower);
        str.push_str("_do");
        str.push_str(&util::lsnake_to_ucamel(&attribut.name));
        str.push_str("InValue(char c, Sj");
        str.push_str(&typ.typename);
        str.push_str("StateEnum *state, SjBuffer *buf, Sj");
        str.push_str(&typ.typename);
        str.push_str(" *");
        str.push_str(&typ_lower);
        str.push_str(") {\n    //printf(\"SJ_");
        str.push_str(&typ_upper);
        str.push_str("_");
        str.push_str(&util::to_upper(&attribut.name));
        str.push_str("_INVALUE : %d\\n\", is_numeric(c));\n    if(is_numeric(c)) {\n        sj_buffer_push(buf, c);\n    } else if (c == ',') {\n        char *b = sj_buffer_get_content(buf);\n        ");
        str.push_str(&typ_lower);
        str.push_str("->");
        str.push_str(&attribut.name);
        str.push_str(" = atoi(b);\n        free(b);\n\n        printf(\"");
        str.push_str(&util::to_upper(&typ_upper));
        str.push_str(": %d\\n\", ");
        str.push_str(&typ_lower);
        str.push_str("->");
        str.push_str(&attribut.name);
        str.push_str(");\n        sj_buffer_clean(buf);\n        *state = SJ_");
        str.push_str(&typ_upper);
        str.push_str("_INOJBECT;\n    } else if (c == '}') {\n        char *b = sj_buffer_get_content(buf);\n        ");
        str.push_str(&typ_lower);
        str.push_str("->");
        str.push_str(&attribut.name);
        str.push_str(" = atoi(b);\n        free(b);\n\n        printf(\"");
        str.push_str(&util::to_upper(&typ_upper));
        str.push_str(": %d\\n\", ");
        str.push_str(&typ_lower);
        str.push_str("->");
        str.push_str(&attribut.name);
        str.push_str(");\n        sj_buffer_clean(buf);\n        *state = SJ_");
        str.push_str(&typ_upper);
        str.push_str("_INITIAL;\n    }// else { return error_code }\n}\n   ");
} else {
// Einzelfunktionen für das Parsen der Attribute  {{= attribut.name 
        str.push_str("\n// TODO: In einzelne Dateien zerlegen für String-Attribute,\n//       Ganzzahl-Attribute oder Gleitpunktzahl-Attribute.");
 } 
      str.push_str("\n");
} 
    str.push_str("");
} 
  str.push_str("");
for typ in (*types).iter() {
    let t = util::to_upper(&typ.typename); 

    str.push_str(" \n\n/*\n * Parser function for Type ");
    str.push_str(&typ.typename);
    str.push_str("\n */\n");
    str.push_str(&typ.typename);
    str.push_str("* sj_parse_");
    str.push_str(&util::ucamel_to_lsnake(&typ.typename) 
);
    str.push_str("(int *pos, int length, char *txt) {\n    Sj");
    str.push_str(&typ.typename);
    str.push_str("Enum state;\n    state = SJ_");
    str.push_str(&t);
    str.push_str("_INITIAL;\n    ");
    str.push_str(&typ.typename);
    str.push_str(" *");
    str.push_str(&util::to_lower(&typ.typename));
    str.push_str(";\n    ");
    str.push_str(&util::to_lower(&typ.typename));
    str.push_str(" = (");
    str.push_str(&typ.typename);
    str.push_str("*)malloc(sizeof(");
    str.push_str(&typ.typename);
    str.push_str("*));\n    char c = NULL; // for current character\n    SjBuffer *buf;\n    buf = sj_buffer_new();\n\n    while((*pos) < length && state != SJ_");
    str.push_str(&t);
    str.push_str("_FINAL) {        \n        c = txt[*pos];        \n        (*pos) += 1;\n        // TODO: Parse content of obj from txt\n        switch(state) {\n            case SJ_");
    str.push_str(&t);
    str.push_str("_INITIAL:\n                sj_");
    str.push_str(&util::to_lower(&t));
    str.push_str("_doInitial(c, &state);\n                break;\n            case SJ_");
    str.push_str(&t);
    str.push_str("_INOBJECT:\n                sj_");
    str.push_str(&util::to_lower(&t));
    str.push_str("_doInObject(c, &state);\n                break;\n            case SJ_");
    str.push_str(&t);
    str.push_str("_INFIELDNAME:\n                sj_");
    str.push_str(&util::to_lower(&t));
    str.push_str("_doInFieldname(c, &state, buf);\n                break;\n            // --\n            // Loop over attributes\n            // to add attribute specific cases                ");
  for attribut in typ.attributes.iter() { 
     let fieldname = util::to_upper(&attribut.name); 

      if attribut.is_array { 
        str.push_str("\n        // Array attribute parser states\n        // TODO: Implementation still missing");
   } else { 
        // Scalar attribute parser states
        if attribut.attribute_type == "string" 
           || attribut.attribute_type == "date"
           || attribut.attribute_type == "datetime"
           || attribut.attribute_type == "time" { 
          str.push_str("\n            case SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_BEHINDFIELDNAME:\n                sj_");
          str.push_str(&util::to_lower(&t));
          str.push_str("_do");
          str.push_str(&util::lsnake_to_ucamel(&attribut.name));
          str.push_str("BehindFieldname(c, &state);\n                break;\n            case SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_INVALUE:\n                sj_");
          str.push_str(&util::to_lower(&t));
          str.push_str("_do");
          str.push_str(&util::lsnake_to_ucamel(&attribut.name));
          str.push_str("InValue(c, &state, buf);\n                break;\n            case SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_INSTRING:\n                sj_");
          str.push_str(&util::to_lower(&t));
          str.push_str("_do");
          str.push_str(&util::lsnake_to_ucamel(&attribut.name));
          str.push_str("InString(c, &state, buf, ");
          str.push_str(&util::to_lower(&t));
          str.push_str(");\n                break;");
     } else if attribut.attribute_type == "int" 
           || attribut.attribute_type == "uint"
           || attribut.attribute_type == "long"
           || attribut.attribute_type == "ulong" { 
          str.push_str("\n            case SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_BEHINDFIELDNAME:\n                sj_");
          str.push_str(&util::to_lower(&t));
          str.push_str("_do");
          str.push_str(&util::lsnake_to_ucamel(&attribut.name));
          str.push_str("BehindFieldname(c, &state);\n                break;\n            case SJ_");
          str.push_str(&t);
          str.push_str("_");
          str.push_str(&fieldname);
          str.push_str("_INVALUE:\n                sj_");
          str.push_str(&util::to_lower(&t));
          str.push_str("_do");
          str.push_str(&util::lsnake_to_ucamel(&attribut.name));
          str.push_str("InValue(c, &state, buf, ");
          str.push_str(&util::to_lower(&t));
          str.push_str(");\n                break;            ");
       }
      } 
   } 
    str.push_str("                        \n            // --\n            case SJ_");
    str.push_str(&t);
    str.push_str("_FINAL:\n                // Debug output, comment it out later\n                printf(\"Finished Parsing of ");
    str.push_str(&t);
    str.push_str(" successfully\\n\");\n                break;\n            default:\n                printf(\"ERROR: invalid parser state %d at position %d\\n\", state, pos);\n                return NULL;                \n        } \n    }    \n    \n    return ");
    str.push_str(&util::to_lower(&typ.typename));
    str.push_str(";\n}");
} 
  str.push_str("");
  let filename = format!("{}/jsoninc_parser.c", folder);
  filehandler::write_file(filename, str);
}


// 
// This generat Method is the entry point of code generation
//
pub fn generate(types:&Box<Vec<Box<model::Type>>>, folder:&str) {
  generate_buffer_code(folder.clone());
  generate_header(types, folder);
  generate_parsers(types, folder);
  let mut str:String = String::new(); 
  str.push_str("/*\n  * C code generated by staticjson\n  */\n\n#include \"sj_buffer.h\"\n#include \"jsoninc_parser.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// data structures");
for typ in (*types).iter() { 
    str.push_str("\nstruct ");
    str.push_str(&util::ucamel_to_lsnake(&typ.typename));
    str.push_str(" {\n  // TODO: Attributes\n};\n");
} 
  str.push_str("\n// end of data structures\n");
  // write it to one single file 
  let filename = format!("{}/main.c", folder);
  filehandler::write_file(filename, str);
} 
