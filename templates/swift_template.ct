{{ // Template for generation of swift based json parsers
use model;
use filehandler;
use util;

// 
// This generat Method is the entry point of code generation
//
pub fn generate(types:&Box<Vec<Box<model::Type>>>, folder:&str) { 
  // generate Classes
  for typ in (*types).iter() {
    let result = gen_type(typ);
    let filename = format!("{}/{}.swift", folder, typ.typename);
    filehandler::write_file(filename, result);
  }
  // generate Parser and Stringifier
}

// Generate single types of the data model
fn gen_type(typ:&Box<model::Type>) -> String {
  let mut str:String = String::new(); 
}}//
//  {{= typ.typename }}.swift
// 

import Foundation

//
// Datastructure for  {{= typ.typename }}
//
public struct  {{= typ.typename }} {
{{ for attr in typ.attributes.iter() { }}
    public var  {{= attr.name }}: {{= translate_basic_type(&attr.attribute_type) }};
{{ } }}

    public init() {
{{ for attr in typ.attributes.iter() { }}
        self. {{= attr.name }} =  {{= get_default_value(&attr.attribute_type) }};
{{ } }}
    }
}

//
// ParserState-Enum for type  {{= typ.typename }}
//
enum  {{= typ.typename }}ParserState {
    case INITIAL
    case INOBJECT
    case INFIELDNAME
    case BEHINDFIELDNAME
    case BEHINDFIELDVALUE
    case FINAL
{{ for attr in typ.attributes.iter() {
  if attr.attribute_type == "string" { 
    if attr.is_array == true { }}
    case IN_ {{= util::to_upper(&attr.name) }}_ARRAY
{{     } }}
    case IN_ {{= util::to_upper(&attr.name) }}_VALUE
    case IN_ {{= util::to_upper(&attr.name) }}_STRING
{{ } else if attr.attribute_type == "date" { }}
    case IN_ {{= util::to_upper(&attr.name) }}_VALUE
    case IN_ {{= util::to_upper(&attr.name) }}_DTSTR
{{ } else { }}
    case IN_ {{= util::to_upper(&attr.name) }}_VALUE
{{   }
} }}
}

//
// Parser and serializer utility class
//
public class  {{= typ.typename }}Util {
  private var state: {{= typ.typename }}ParserState;

  init() {
    self.state =  {{= typ.typename }}ParserState.INITIAL;
  }

  //
  // Parsing-Function for type  {{= typ.typename }}
  //
  public func parse(json:String) ->  {{= typ.typename }} {
    var ptr = indices(code).generate();
    return parse_internal(code, ptr:&ptr);
  }

  //
  // Internal parsing function, directly called by same classes parse function
  // and any other class which has nested objects of this type.
  // 
  public func parse_internal(code:String, inout ptr:RangeGenerator<String.Index>) ->  {{= typ.typename }} {
    var obj: {{= typ.typename }} =  {{= typ.typename }}();
    var c:Character = " ";
    var charbefore:Character = " ";
    var buf = "";

    while ptr.startIndex < ptr.endIndex && self.state !=  {{= typ.typename }}ParserState.FINAL {
      c = code[ptr.startIndex];
      switch self.state {
        case .INITIAL: 
          if c == "{" {
            self.state =  {{= typ.typename }}ParserState.INOBJECT;
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
        case .INOBJECT:
          if c == "\"" {
            self.state =  {{= typ.typename }}ParserState.IN_FIELDNAME;
            buf = "";
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
        case .IN_FIELDNAME:
          if c == "\"" && charbefore != "\\" {
            self.state =  {{= typ.typename }}ParserState.BEHIND_FIELDNAME;
          } else {
            buf.append(c);
          }
        case .BEHIND_FIELDNAME:
          if c == ":" {
            if buf == "" {
              // TODO: Handle syntax error, empty names are not allowed
{{ for attr in typ.attributes.iter() { }}
            } else if buf == " {{= attr.name}}" {
              self.state =  {{= typ.typename }}ParserState.IN_ {{= util::to_upper(&attr.name) }}_VALUE;
{{ } }}
            }
            // TODO: if Strict-Mode then else with error output
            // TODO: if flex-Mode then do something to overjump unknown attributes
            buf = "";
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
        default:
          // This state is not allwoed to be reached
          println("ERROR: ENCOUNTERED INVALID STATE");
      }
      charbefore = c;
      ptr.next();
    }
 
    return obj;
  }

  //
  // Function to serialize objects of type  {{= typ.typename }}
  //
  public func serialize(obj: {{= typ.typename }}) -> String {
    var buf = "{";
{{ for attr in typ.attributes.iter() { }}
    buf.append("\"");
    buf.append(" {{= attr.name }}");
    buf.append("\":");
{{   if attr.is_array {  }}
      buf.append("[");
      for val in obj. {{= attr.name }} {
{{       if attr.attribute_type == "string" { }}
        buf.append("\"");
        buf.append(obj. {{= attr.name }});
        buf.append("\"");
{{       } else { }} 
        buf.append(obj. {{= attr.name }});
{{       } }}       
      }
      buf.append("]");
{{   } else if attr.attribute_type == "string" {  }}
    buf.append("\"");
    buf.append(attr.name);
    buf.append("\"");
{{   } else { }}
    buf.append(obj. {{= attr.name }});
{{   } }}
{{ } }}
    buf.append("}");
    return buf;
  }

}

{{   return str;
} 

// Translate staticjsons basic types into swift types
fn translate_basic_type(tname:&str) -> String {
  let mut result = String::new();
  if !model::Type::is_basic_type(tname) {
    result.push_str(tname);
  } else if tname == "string" {
    result.push_str("String");
  } else if tname == "int" {
    result.push_str("Int32");
  } else if tname == "uint" {
    result.push_str("UInt32");
  } else if tname == "decimal" {
    result.push_str("decimal");
  } else if tname == "byte" {
    result.push_str("UInt8");
  } else if tname == "char" {
    result.push_str("Character");
  } else if tname == "long" {
    result.push_str("Int64");
  } else if tname == "ulong" {
    result.push_str("UInt64");
  } else if tname == "date" {
    result.push_str("NSDate");
  } else {
    result.push_str("XXXXXXXX");
  }
  return result;
}

// Offer swift initial values for staticjson basic types
fn get_default_value(tname:&str) -> String {
  let mut result = String::new();
  if !model::Type::is_basic_type(tname) {
    result.push_str(tname);
    result.push_str("()");
  } else if tname == "string" {
    result.push_str("\"\"");
  } else if tname == "int" {
    result.push_str("0");
  } else if tname == "uint" {
    result.push_str("0");
  } else if tname == "decimal" {
    result.push_str("0.0");
  } else if tname == "byte" {
    result.push_str("0");
  } else if tname == "char" {
    result.push_str("' '");
  } else if tname == "long" {
    result.push_str("0");
  } else if tname == "ulong" {
    result.push_str("0");
  } else if tname == "date" {
    result.push_str("NSDate()");
  } else {
    result.push_str("XXXXXXXX");
  }
  return result;
}

}}
