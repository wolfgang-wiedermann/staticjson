{{ // Template for generation of swift based json parsers
use model;
use filehandler;
use util;

// 
// This generat Method is the entry point of code generation
//
pub fn generate(types:&Box<Vec<Box<model::Type>>>, folder:&str) { 
  // generate Classes
  for typ in (*types).iter() {
    let result = gen_type(typ);
    let filename = format!("{}/{}.swift", folder, typ.typename);
    filehandler::write_file(filename, result);
  }
  // generate Parser and Stringifier
}

// Generate single types of the data model
fn gen_type(typ:&Box<model::Type>) -> String {
  let mut str:String = String::new(); 
}}//
//  {{= typ.typename }}.swift
// 

import Foundation

//
// Datastructure for  {{= typ.typename }}
//
public struct  {{= typ.typename }} {
{{ for attr in typ.attributes.iter() { }}
    public var  {{= attr.name }}: {{= translate_basic_type(&attr.attribute_type) }};
{{ } }}

    public init() {
{{ for attr in typ.attributes.iter() { }}
        self. {{= attr.name }} =  {{= get_default_value(&attr.attribute_type) }};
{{ } }}
    }
}

//
// ParserState-Enum for type  {{= typ.typename }}
//
enum  {{= typ.typename }}ParserState {
    case INITIAL
    case INOBJECT
    case INFIELDNAME
    case BEHINDFIELDNAME
    case BEHINDFIELDVALUE
    case FINAL
{{ for attr in typ.attributes.iter() {
  if attr.attribute_type == "string" { 
    if attr.is_array == true { }}
    case IN_ {{= util::to_upper(&attr.name) }}_ARRAY
{{     } }}
    case IN_ {{= util::to_upper(&attr.name) }}_VALUE
    case IN_ {{= util::to_upper(&attr.name) }}_STRING
{{ } else if attr.attribute_type == "date" { }}
    case IN_ {{= util::to_upper(&attr.name) }}_VALUE
    case IN_ {{= util::to_upper(&attr.name) }}_DTSTR
{{ } else { }}
    case IN_ {{= util::to_upper(&attr.name) }}_VALUE
{{   }
} }}
}

//
// Parser and serializer utility class
//
class  {{= typ.typename }}Util {

  //
  // Parsing-Function for type  {{= typ.typename }}
  //
  func parse(json:String) ->  {{= typ.typename }} {
    var entity: {{= typ.typename }} =  {{= typ.typename }}();

    // TODO: continue here with generation of parser code

    return entity;
  } 

  //
  // Function to serialize objects of type  {{= typ.typename }}
  //
  func serialize(obj: {{= typ.typename }}) -> String {
    var buf = "{";
{{ for attr in typ.attributes.iter() { }}
    buf.append("\"");
    buf.append(" {{= attr.name }}");
    buf.append("\":");
{{   if attr.is_array {  }}
      buf.append("[");
      for val in obj. {{= attr.name }} {
{{       if attr.attribute_type == "string" { }}
        buf.append("\"");
        buf.append(obj. {{= attr.name }});
        buf.append("\"");
{{       } else { }} 
        buf.append(obj. {{= attr.name }});
{{       } }}       
      }
      buf.append("]");
{{   } else if attr.attribute_type == "string" {  }}
    buf.append("\"");
    buf.append(attr.name);
    buf.append("\"");
{{   } else { }}
    buf.append(obj. {{= attr.name }});
{{   } }}
{{ } }}
    buf.append("}");
    return buf;
  }

}

{{   return str;
} 

// Translate staticjsons basic types into swift types
fn translate_basic_type(tname:&str) -> String {
  let mut result = String::new();
  if !model::Type::is_basic_type(tname) {
    result.push_str(tname);
  } else if tname == "string" {
    result.push_str("String");
  } else if tname == "int" {
    result.push_str("Int32");
  } else if tname == "uint" {
    result.push_str("UInt32");
  } else if tname == "decimal" {
    result.push_str("decimal");
  } else if tname == "byte" {
    result.push_str("UInt8");
  } else if tname == "char" {
    result.push_str("Character");
  } else if tname == "long" {
    result.push_str("Int64");
  } else if tname == "ulong" {
    result.push_str("UInt64");
  } else if tname == "date" {
    result.push_str("NSDate");
  } else {
    result.push_str("XXXXXXXX");
  }
  return result;
}

// Offer swift initial values for staticjson basic types
fn get_default_value(tname:&str) -> String {
  let mut result = String::new();
  if !model::Type::is_basic_type(tname) {
    result.push_str(tname);
    result.push_str("()");
  } else if tname == "string" {
    result.push_str("\"\"");
  } else if tname == "int" {
    result.push_str("0");
  } else if tname == "uint" {
    result.push_str("0");
  } else if tname == "decimal" {
    result.push_str("0.0");
  } else if tname == "byte" {
    result.push_str("0");
  } else if tname == "char" {
    result.push_str("' '");
  } else if tname == "long" {
    result.push_str("0");
  } else if tname == "ulong" {
    result.push_str("0");
  } else if tname == "date" {
    result.push_str("NSDate()");
  } else {
    result.push_str("XXXXXXXX");
  }
  return result;
}

}}
