{{ // Template for generation of swift based json parsers
use model;
use filehandler;
use util;

// 
// This generat Method is the entry point of code generation
//
pub fn generate(types:&Box<Vec<Box<model::Type>>>, folder:&str) { 
  // generate Classes
  for typ in (*types).iter() {
    let result = gen_type(typ);
    let filename = format!("{}/{}.swift", folder, typ.typename);
    filehandler::write_file(filename, result);
  }
  // generate Parser and Stringifier
}

// Generate single types of the data model
fn gen_type(typ:&Box<model::Type>) -> String {
  let mut str:String = String::new(); 
}}//
//  {{= typ.typename }}.swift
// 

import Foundation

//
// Datastructure for  {{= typ.typename }}
//
public struct  {{= typ.typename }} {
{{ for attr in typ.attributes.iter() { }}
    public var  {{= attr.name }}: {{= translate_basic_type(&attr.attribute_type) }};
{{ } }}

    public init() {
{{ for attr in typ.attributes.iter() { }}
        self. {{= attr.name }} =  {{= get_default_value(&attr.attribute_type) }};
{{ } }}
    }

    //
    // ParserState-Enum for type  {{= typ.typename }}
    //
    private enum  {{= typ.typename }}ParserState {
        case INITIAL
        case INOBJECT
        case IN_FIELDNAME
        case BEHIND_FIELDNAME
        case BEHIND_FIELDVALUE
        case FINAL
{{ for attr in typ.attributes.iter() {
  if attr.attribute_type == "string" { 
    if attr.is_array == true { }}
        case IN_ {{= util::to_upper(&attr.name) }}_ARRAY
{{     } }}
        case IN_ {{= util::to_upper(&attr.name) }}_VALUE
        case IN_ {{= util::to_upper(&attr.name) }}_STRING
{{ } else if attr.attribute_type == "date" { }}
        case IN_ {{= util::to_upper(&attr.name) }}_VALUE
        case IN_ {{= util::to_upper(&attr.name) }}_STRING
{{ } else if !model::Type::is_basic_type(&attr.attribute_type) { }}
        case IN_ {{= util::to_upper(&attr.name) }}_OBJECT
{{ } else { }}
        case IN_ {{= util::to_upper(&attr.name) }}_VALUE
{{   }
} }}
    }

  //
  // Parsing-Function for type  {{= typ.typename }}
  //
  public static func parse(code:String) ->  {{= typ.typename }} {
    var ptr = indices(code).generate();
    return parse_internal(code, ptr:&ptr);
  }

  //
  // Internal parsing function, directly called by same classes parse function
  // and any other class which has nested objects of this type.
  // 
  public static func parse_internal(code:String, inout ptr:RangeGenerator<String.Index>) ->  {{= typ.typename }} {
    var obj: {{= typ.typename }} =  {{= typ.typename }}();
    var c:Character = " ";
    var charbefore:Character = " ";
    var buf = "";
    var state =  {{= typ.typename }}ParserState.INITIAL;

    while ptr.startIndex < ptr.endIndex && state !=  {{= typ.typename }}ParserState.FINAL {
      c = code[ptr.startIndex];
      switch state {
        case .INITIAL: 
          if c == "{" {
            state =  {{= typ.typename }}ParserState.INOBJECT;
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
        case .INOBJECT:
          if c == "\"" {
            state =  {{= typ.typename }}ParserState.IN_FIELDNAME;
            buf = "";
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
        case .IN_FIELDNAME:
          if c == "\"" && charbefore != "\\" {
            state =  {{= typ.typename }}ParserState.BEHIND_FIELDNAME;
          } else {
            buf.append(c);
          }
        case .BEHIND_FIELDNAME:
          if c == ":" {
            if buf == "" {
              // TODO: Handle syntax error, empty names are not allowed
{{ for attr in typ.attributes.iter() { }}
            } else if buf == " {{= attr.name}}" {
{{ if !model::Type::is_basic_type(&attr.attribute_type) { }}
              state =  {{= typ.typename }}ParserState.IN_ {{= util::to_upper(&attr.name) }}_OBJECT;
{{ } else { }}
              state =  {{= typ.typename }}ParserState.IN_ {{= util::to_upper(&attr.name) }}_VALUE;
{{ } 
} }}
            }
            // TODO: if Strict-Mode then else with error output
            // TODO: if flex-Mode then do something to overjump unknown attributes
            buf = "";
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
        case .BEHIND_FIELDVALUE:
          if c == "," {
            state =  {{= typ.typename }}ParserState.INOBJECT;
          } else if c == "}" {
            state =  {{= typ.typename }}ParserState.FINAL;
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
{{ for attr in typ.attributes.iter() { 
    if !model::Type::is_basic_type(&attr.attribute_type) { }}
        // Nested objects
        case .IN_ {{= util::to_upper(&attr.name) }}_OBJECT:
          if c == "{" {
            obj. {{= attr.name }} =  {{= attr.attribute_type}}.parse_internal(code, ptr:&ptr);
            state =  {{= typ.typename }}ParserState.BEHIND_FIELDVALUE;
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
{{ } else if attr.attribute_type == "string"
        || attr.attribute_type == "char" { }}
        // Strings and other values enclosed by "
        case .IN_ {{= util::to_upper(&attr.name) }}_VALUE:
          if c == "\"" {
            state =  {{= typ.typename }}ParserState.IN_ {{= util::to_upper(&attr.name) }}_STRING;
            buf = "";
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
        case .IN_ {{= util::to_upper(&attr.name) }}_STRING:
          if c == "\"" && charbefore != "\\" {
            state =  {{= typ.typename }}ParserState.BEHIND_FIELDVALUE;
            obj. {{= attr.name }} = buf;
            buf = "";
          } else {
            buf.append(c);
          }
{{ } else if  attr.attribute_type == "date"
        || attr.attribute_type == "time"
        || attr.attribute_type == "datetime" { }}
        // Strings and other values enclosed by "
        case .IN_ {{= util::to_upper(&attr.name) }}_VALUE:
          if c == "\"" {
            state =  {{= typ.typename }}ParserState.IN_ {{= util::to_upper(&attr.name) }}_STRING;
            buf = "";
          } else if !is_blank(c) {
            // TODO: Handle syntax error
          }
        case .IN_ {{= util::to_upper(&attr.name) }}_STRING:
          if c == "\"" && charbefore != "\\" {
            state =  {{= typ.typename }}ParserState.BEHIND_FIELDVALUE;
            obj. {{= attr.name }} = NSDate(string:buf)!; // TODO: prepare for other date types too
            buf = "";
          } else {
            buf.append(c);
          }
{{   } else if attr.attribute_type == "int"
            || attr.attribute_type == "uint"
            || attr.attribute_type == "long"
            || attr.attribute_type == "ulong" {  }}
        // int-type values without "
        case .IN_ {{= util::to_upper(&attr.name) }}_VALUE:
          if c == "," { 
            state =  {{= typ.typename }}ParserState.INOBJECT;
{{     // Make string to int conversion dependent to target type }}
{{     if attr.attribute_type == "int" { }}
            obj. {{= attr.name }} = Int32(buf.toInt()!);
{{     } else if attr.attribute_type == "uint" { }}
            obj. {{= attr.name }} = UInt32(buf.toInt()!);
{{     } else if attr.attribute_type == "long" { }}
            obj. {{= attr.name }} = Int64(buf.toInt()!);
{{     } else if attr.attribute_type == "ulong" { }}
            obj. {{= attr.name }} = UInt64(buf.toInt()!);
{{     } }}
          } else if c == "}" {
            state =  {{= typ.typename }}ParserState.FINAL;
            // TODO: code it out
          } else if c >= "0" && c <= "9" {
            // TODO: also allow - for int and long (not for uint and ulong)
            buf.append(c);
{{     if attr.attribute_type == "int" || attr.attribute_type == "long" { }}
          } else if c == "-" && buf == "" {
            buf.append(c);
{{     } }}
          } else {
            // TODO: Handle syntax error
          }
{{   } else { }}
        // Other numeric values whithout "
        // TODO: code it out !!!
{{   } }}
{{ } }}
        default:
          // This state is not allwoed to be reached
          println("ERROR: ENCOUNTERED INVALID STATE");
      }
      charbefore = c;
      ptr.next();
    }
 
    return obj;
  }

  //
  // Function to serialize objects of type  {{= typ.typename }}
  //
  public static func serialize(obj: {{= typ.typename }}) -> String {
    var buf = "{";
{{ for attr in typ.attributes.iter() { }}
    buf += "\"";
    buf += " {{= attr.name }}";
    buf += "\":";
{{   if attr.is_array {  }}
      buf += "[";
      for val in obj. {{= attr.name }} {
{{       if attr.attribute_type == "string" { }}
        buf += "\"";
        buf += "\(obj. {{= attr.name }})";
        buf += "\"";
{{       } else { }} 
        buf += "\(obj. {{= attr.name }})";
{{       } }}       
      }
      buf += "]";
{{   } else if attr.attribute_type == "string" {  }}
    buf += "\"";
    buf += "\(obj. {{= attr.name}})";
    buf += "\"";
{{   } else { }}
    buf += "\(obj. {{= attr.name }})";
{{   } }}
{{ } }}
    buf += "}";
    return buf;
  }

}

{{   return str;
} 

// Translate staticjsons basic types into swift types
fn translate_basic_type(tname:&str) -> String {
  let mut result = String::new();
  if !model::Type::is_basic_type(tname) {
    result.push_str(tname);
  } else if tname == "string" {
    result.push_str("String");
  } else if tname == "int" {
    result.push_str("Int32");
  } else if tname == "uint" {
    result.push_str("UInt32");
  } else if tname == "decimal" {
    result.push_str("Double");
  } else if tname == "byte" {
    result.push_str("UInt8");
  } else if tname == "char" {
    result.push_str("Character");
  } else if tname == "long" {
    result.push_str("Int64");
  } else if tname == "ulong" {
    result.push_str("UInt64");
  } else if tname == "date" {
    result.push_str("NSDate");
  } else {
    result.push_str("XXXXXXXX");
  }
  return result;
}

// Offer swift initial values for staticjson basic types
fn get_default_value(tname:&str) -> String {
  let mut result = String::new();
  if !model::Type::is_basic_type(tname) {
    result.push_str(tname);
    result.push_str("()");
  } else if tname == "string" {
    result.push_str("\"\"");
  } else if tname == "int" {
    result.push_str("0");
  } else if tname == "uint" {
    result.push_str("0");
  } else if tname == "decimal" {
    result.push_str("0.0");
  } else if tname == "byte" {
    result.push_str("0");
  } else if tname == "char" {
    result.push_str("' '");
  } else if tname == "long" {
    result.push_str("0");
  } else if tname == "ulong" {
    result.push_str("0");
  } else if tname == "date" {
    result.push_str("NSDate()");
  } else {
    result.push_str("XXXXXXXX");
  }
  return result;
}

}}
