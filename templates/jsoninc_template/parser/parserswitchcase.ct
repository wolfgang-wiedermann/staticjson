        switch(state) {
            case SJ_ {{= t }}_INITIAL:
                sj_ {{= util::to_lower(&t) }}_doInitial(c, &state);
                break;
            case SJ_ {{= t }}_INOBJECT:
                sj_ {{= util::to_lower(&t) }}_doInObject(c, &state);
                break;
            case SJ_ {{= t }}_INFIELDNAME:
                sj_ {{= util::to_lower(&t) }}_doInFieldname(c, &state, buf);
                break;
            // --
            // Loop over attributes
            // to add attribute specific cases                
{{   for attribut in typ.attributes.iter() { 
     let fieldname = util::to_upper(&attribut.name); 

      if attribut.is_array { }}
        // Array attribute parser states
        // TODO: Implementation still missing
{{    } else { 
        // Scalar attribute parser states
        if attribut.attribute_type == "string" 
           || attribut.attribute_type == "date"
           || attribut.attribute_type == "datetime"
           || attribut.attribute_type == "time" { }}
            case SJ_ {{= t }}_ {{= fieldname }}_BEHINDFIELDNAME:
                sj_ {{= util::to_lower(&t) }}_do {{= util::lsnake_to_ucamel(&attribut.name) }}BehindFieldname(c, &state);
                break;
            case SJ_ {{= t }}_ {{= fieldname }}_INVALUE:
                sj_ {{= util::to_lower(&t) }}_do {{= util::lsnake_to_ucamel(&attribut.name) }}InValue(c, &state, buf);
                break;
            case SJ_ {{= t }}_ {{= fieldname }}_INSTRING:
                sj_ {{= util::to_lower(&t) }}_do {{= util::lsnake_to_ucamel(&attribut.name) }}InString(c, &state, buf,  {{= util::to_lower(&t) }});
                break;
{{      } else if attribut.attribute_type == "int" 
           || attribut.attribute_type == "uint"
           || attribut.attribute_type == "long"
           || attribut.attribute_type == "ulong" { }}
            case SJ_ {{= t }}_ {{= fieldname }}_BEHINDFIELDNAME:
                sj_ {{= util::to_lower(&t) }}_do {{= util::lsnake_to_ucamel(&attribut.name) }}BehindFieldname(c, &state);
                break;
            case SJ_ {{= t }}_ {{= fieldname }}_INVALUE:
                sj_ {{= util::to_lower(&t) }}_do {{= util::lsnake_to_ucamel(&attribut.name) }}InValue(c, &state, buf,  {{= util::to_lower(&t) }});
                break;            
{{        }
      } 
   } }}                        
            // --
            case SJ_ {{= t }}_FINAL:
                // Debug output, comment it out later
                printf("Finished Parsing of  {{= t }} successfully\n");
                break;
            default:
                printf("ERROR: invalid parser state %d at position %d\n", state, pos);
                return NULL;                
        }